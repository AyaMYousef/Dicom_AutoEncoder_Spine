// Generated by CoffeeScript 1.8.0
(function() {
  var Encoder, err_cb, fs, log, printf, sink, source, stream, tags, uids, vrs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  vrs = require("../lib/vrs");

  uids = require("../lib/uids");

  tags = require("../lib/tags");

  stream = require("stream");

  printf = require("printf");

  log = require("./logger")('encoder');

  Encoder = (function(_super) {
    __extends(Encoder, _super);

    function Encoder(options) {
      var ts, ts_name;
      if (!(this instanceof Encoder)) {
        return new Encoder(options);
      }
      Encoder.__super__.constructor.call(this, options);
      this._writableState.objectMode = true;
      this._readableState.objectMode = false;
      this.context = new vrs.ContextStack();
      ts_name = options != null ? options.transfer_syntax : void 0;
      if (!ts_name) {
        ts_name = 'ExplicitVRLittleEndian';
      }
      ts = uids.for_uid(ts_name);
      this.context.push(ts.make_context());
      log.debug({
        encoder: this.log_summary()
      }, "encoder initialized");
    }

    Encoder.prototype._transform = function(obj, encoding, cb) {
      var err;
      try {
        if (log.trace()) {
          log.trace(obj != null ? typeof obj.log_summary === "function" ? obj.log_summary() : void 0 : void 0, "Encoder _transform");
        }
        switch (obj.command) {
          case 'element':
            obj.vr._encode_and_emit(obj.element, this);
            break;
          case 'start_sequence':
            obj.vr._encode_and_emit_seq(obj.element, this);
            break;
          case 'end_sequence':
            this._emit_std_tag_and_value_length(tags.SequenceDelimitationItem.tag, 0);
            break;
          case 'start_item':
            this._emit_std_tag_and_value_length(tags.Item.tag, vrs.UNDEFINED_LENGTH);
            break;
          case 'end_item':
            this._emit_std_tag_and_value_length(tags.ItemDelimitationItem.tag, 0);
            break;
          case 'start_element':
            this._handle_start_element(obj);
            break;
          case 'end_element':
            this._handle_end_element(obj);
            break;
          default:
            this._handle_raw(obj);
        }
        return cb();
      } catch (_error) {
        err = _error;
        return this.emit('error', err);
      }
    };

    Encoder.prototype._emit_std_tag_and_value_length = function(tag, value_length) {
      var ul;
      tag = new vrs.AT(this.context.top(), null, [tag]);
      log.trace({
        tag: tag,
        value_length: value_length
      }, "_emit_std_element_and_value_length");
      this.push(tag.buffer);
      ul = new vrs.UL(this.context.top_little_endian(), null, [value_length]);
      return this.push(ul.buffer);
    };

    Encoder.prototype.log_summary = function() {
      var summary;
      return summary = {
        context: this.context.log_summary()
      };
    };

    return Encoder;

  })(stream.Transform);

  module.exports = Encoder;

  err_cb = function(err) {
    console.error("Error:", err);
    console.error("Stack trace:", err.stack);
    return process.exit(10);
  };

  if (require.main === module) {
    fs = require("fs");
    sink = require("./json/sink");
    source = require("./json/source");
    fs.createReadStream(process.argv[2]).pipe(sink(function(err, data) {
      if (err) {
        return err_cb(err);
      }
      log.trace({
        json: data
      }, "Processing JSON:");
      return source(data).on('error', err_cb).pipe(new Encoder()).on('error', err_cb).pipe(fs.createWriteStream(process.argv[3] || "/tmp/x.x")).on('error', err_cb);
    }));
  }

}).call(this);
