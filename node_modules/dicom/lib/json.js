// Generated by CoffeeScript 1.8.0
(function() {
  var ConcatStream, JsonEncoder, JsonSink, JsonSource, decoder, decoder2json, file2json, file2jsonstream, filename, fs, get_element, get_value, get_values, get_vr, gunzip2json, gunzip2jsonstream, input, log, minimist, options, printf, sink, stream, tags, zlib, _COMPATIBILITY, _err_cb, _get_bulkdata_uri, _get_filename,
    __slice = [].slice;

  fs = require("fs");

  stream = require("stream");

  zlib = require("zlib");

  printf = require("printf");

  ConcatStream = require("concat-stream");

  minimist = require("minimist");

  tags = require("../lib/tags");

  decoder = require("../lib/decoder");

  log = require("./logger")("json");

  JsonEncoder = require("./json/encoder");

  JsonSink = require("./json/sink");

  JsonSource = require("./json/source");

  _COMPATIBILITY = true;

  if (_COMPATIBILITY) {
    exports.JsonEncoder = JsonEncoder;
    exports.JsonSink = JsonSink;
    exports.JsonSource = JsonSource;
  }

  get_element = function() {
    var json, lookup, must_pop, p, path, result, x, _i, _j, _len, _len1;
    json = arguments[0], path = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    lookup = [];
    must_pop = false;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      if ((typeof p) === 'number') {
        lookup.push(p);
        must_pop = false;
      } else {
        lookup.push(tags.for_tag(p).tag_str);
        lookup.push("Value");
        must_pop = true;
      }
    }
    if (must_pop) {
      lookup.pop();
    }
    result = json;
    for (_j = 0, _len1 = lookup.length; _j < _len1; _j++) {
      x = lookup[_j];
      result = result != null ? result[x] : void 0;
    }
    return result;
  };

  get_values = function() {
    var json, path, _ref;
    json = arguments[0], path = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = get_element.apply(null, [json].concat(__slice.call(path)))) != null ? _ref.Value : void 0;
  };

  get_value = function() {
    var json, path, _ref;
    json = arguments[0], path = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = get_values.apply(null, [json].concat(__slice.call(path)))) != null ? _ref[0] : void 0;
  };

  get_vr = function() {
    var json, path, _ref;
    json = arguments[0], path = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = get_element.apply(null, [json].concat(__slice.call(path)))) != null ? _ref.vr : void 0;
  };

  _get_filename = function(obj_or_fn) {
    if (typeof obj_or_fn === 'string') {
      return obj_or_fn;
    } else {
      return obj_or_fn.filename;
    }
  };

  _get_bulkdata_uri = function(obj_or_fn) {
    var _ref;
    if (typeof obj_or_fn === 'string') {
      return obj_or_fn;
    } else {
      return (_ref = obj_or_fn.bulkdata_uri) != null ? _ref : obj_or_fn.filename;
    }
  };

  file2jsonstream = function(fn, cb) {
    return fs.createReadStream(_get_filename(fn)).on('error', cb).pipe(decoder({
      guess_header: true
    })).on('error', cb).pipe(new JsonEncoder({
      bulkdata_uri: _get_bulkdata_uri(fn)
    })).on('error', cb);
  };

  file2json = function(fn, cb) {
    return file2jsonstream(fn, cb).pipe(new JsonSink(cb)).on('error', cb);
  };

  gunzip2jsonstream = function(fn, cb) {
    return fs.createReadStream(_get_filename(fn)).on('error', cb).pipe(zlib.createGunzip()).on('error', cb).pipe(decoder({
      guess_header: true
    })).on('error', cb).pipe(new JsonEncoder({
      bulkdata_uri: _get_bulkdata_uri(fn)
    })).on('error', cb);
  };

  gunzip2json = function(fn, cb) {
    return gunzip2jsonstream(fn, cb).pipe(new JsonSink(cb)).on('error', cb);
  };

  decoder2json = function(opts, cb) {
    var _dec;
    _dec = new decoder(opts);
    _dec.on('error', cb).pipe(new JsonEncoder(opts)).on('error', cb).pipe(new JsonSink(cb)).on('error', cb);
    return _dec;
  };

  exports.get_element = get_element;

  exports.get_values = get_values;

  exports.get_value = get_value;

  exports.get_vr = get_vr;

  exports.file2jsonstream = file2jsonstream;

  exports.gunzip2jsonstream = gunzip2jsonstream;

  exports.file2json = file2json;

  exports.gunzip2json = gunzip2json;

  exports.decoder2json = decoder2json;

  _err_cb = function(err) {
    console.error("Error:", err.stack);
    return process.exit(1);
  };

  if (require.main === module) {
    options = minimist(process.argv.slice(2), {
      boolean: ['gunzip', 'emit'],
      alias: {
        z: 'gunzip',
        'e': 'emit'
      }
    });
    filename = options._[0];
    if (options.gunzip) {
      input = gunzip2jsonstream(filename, _err_cb);
    } else {
      input = file2jsonstream(filename, _err_cb);
    }
    if (options.emit) {
      sink = new JsonSink(function(err, data) {
        var source;
        if (err) {
          throw err;
        }
        log.info("setting up json source");
        source = new JsonSource(data);
        return source.pipe(process.stdout);
      });
      input.pipe(sink);
    } else {
      input.pipe(process.stdout);
    }
  }

}).call(this);
