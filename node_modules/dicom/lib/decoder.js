// Generated by CoffeeScript 1.8.0
(function() {
  var ByteStreamer, Decoder, fs, log, printf, readbuffer, stream, tags, uids, vrs,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  vrs = require("./vrs");

  readbuffer = require("./readbuffer");

  uids = require("../lib/uids");

  tags = require("../lib/tags");

  fs = require("fs");

  stream = require("stream");

  printf = require("printf");

  log = require("./logger")('decoder');

  Decoder = (function(_super) {
    __extends(Decoder, _super);

    function Decoder(options) {
      this._consume_std_value_length = __bind(this._consume_std_value_length, this);
      this._decode_datafile = __bind(this._decode_datafile, this);
      this._guess_header = __bind(this._guess_header, this);
      this._decode_dataelement = __bind(this._decode_dataelement, this);
      this._decode_metaelement = __bind(this._decode_metaelement, this);
      this._decode_dataset = __bind(this._decode_dataset, this);
      this._decode_metainfo = __bind(this._decode_metainfo, this);
      this._metainfo_done_cb = __bind(this._metainfo_done_cb, this);
      var ts, ts_name;
      if (!(this instanceof Decoder)) {
        return new Decoder(options);
      }
      Decoder.__super__.constructor.call(this, options);
      this.streaming_value_length_minimum = options != null ? options.streaming_value_length_minimum : void 0;
      this._writableState.objectMode = false;
      this._readableState.objectMode = true;
      this.context = new vrs.ContextStack();
      ts_name = options != null ? options.transfer_syntax : void 0;
      if (!ts_name) {
        ts_name = 'ExplicitVRLittleEndian';
      }
      ts = uids.for_uid(ts_name);
      this.context.push(ts.make_context());
      this.buffer = readbuffer();
      if (options != null ? options.read_header : void 0) {
        log.debug("initial state: read_header");
        this.state = this._decode_datafile;
      } else if (options != null ? options.guess_header : void 0) {
        log.debug("initial state: guess_header");
        this.state = this._guess_header;
      } else {
        log.debug("initial state: decode_dataset");
        this.state = this._decode_dataset;
      }
      log.debug({
        decoder: this.log_summary()
      }, "decoder initialized");
    }

    Decoder.prototype.log_summary = function() {
      var summary;
      return summary = {
        buffer: this.buffer.log_summary(),
        context: this.context.log_summary()
      };
    };

    Decoder.prototype._transform = function(chunk, encoding, cb) {
      this.buffer.push(chunk);
      if (log.debug()) {
        log.debug({
          buffer: this.buffer.log_summary()
        }, "_transform");
      }
      this._action_wrapper(this.state);
      if (log.debug()) {
        log.debug({
          buffer: this.buffer.log_summary()
        }, "_transform done, calling cb");
      }
      return cb();
    };

    Decoder.prototype._flush = function(cb) {
      this._action_wrapper(this.state);
      if (this.buffer.length === 0 && this.context.stack_depth() === 1 && this.saved.stream_position === this.buffer.stream_position) {
        log.debug("_flush successful, all is well with our decode");
        return cb();
      } else {
        log.debug({
          buffer: this.buffer.length,
          context: this.context.stack_depth(),
          saved: this.saved.stream_position,
          position: this.buffer.stream_position
        }, "_flush: can not flush (length should be 0, stack depth 1)");
        return this.emit('error', new vrs.UnexpectedEofOfFile());
      }
    };

    Decoder.prototype._switch_state = function(state, msg) {
      if (!state) {
        state = this._decode_dataset;
      }
      log.debug({
        state: state
      }, "switching state: " + msg + " ==> " + state);
      return this.state = state;
    };

    Decoder.prototype._metainfo_done_cb = function() {
      var ts;
      log.debug("metainfo callback, setting metainfo_done");
      this.metainfo_done = true;
      this._switch_state(this._decode_dataset, "metainfo done, decoding dataset");
      if (this.metainfo_listener) {
        this.removeListener('data', this.metainfo_listener);
        this.metainfo_listener = void 0;
      }
      log.debug("ts=" + this.metainfo_ts);
      ts = uids.for_uid(this.metainfo_ts);
      log.debug({
        ts: ts
      }, "_decode_metainfo: switching transfer syntax");
      return this.context.replace_root(ts.make_context());
    };

    Decoder.prototype._decode_metainfo = function() {
      var start_pos;
      if (!this.metainfo_ts) {
        this.saved = this.buffer.copy();
        start_pos = this.buffer.stream_position;
        this.metainfo_done = false;
        if (!this.metainfo_listener) {
          this.metainfo_listener = (function(_this) {
            return function(event) {
              if (event.element.tag === 0x00020010) {
                _this.metainfo_ts = event.vr.value();
                return log.debug({
                  ts: _this.metainfo_ts
                }, "metainfo transfer syntax found");
              }
            };
          })(this);
          this.on('data', this.metainfo_listener);
        }
      }
      while (!this.metainfo_done) {
        this._decode_metaelement();
      }
      return this._decode_dataset();
    };

    Decoder.prototype._decode_dataset = function() {
      while (true) {
        this._decode_dataelement();
      }
      return void 0;
    };

    Decoder.prototype._decode_metaelement = function() {
      var element_position, group_str, tag, tag_str;
      this.saved = this.buffer.copy();
      if (log.trace()) {
        log.trace({
          buffer: this.saved.log_summary()
        }, "_decode_metaelement: saved buffer state");
      }
      element_position = this.buffer.stream_position;
      this.context.handle_autopops(element_position);
      tag = (new vrs.AT(this.context.top())).consume_value(this.buffer);
      if (log.debug()) {
        log.debug({
          tag: printf("%08x", tag)
        }, "decoded tag");
      }
      tag_str = printf("%08X", tag);
      group_str = tag_str.substr(0, 4);
      if (group_str !== "0002") {
        log.debug({
          tag: tag_str
        }, "end of metainfo");
        this.buffer = this.saved;
        return this._metainfo_done_cb();
      }
      switch (tag_str) {
        case tags.Item.mask:
          return this._handle_item(tag, element_position);
        case tags.ItemDelimitationItem.mask:
          return this._handle_itemdelimitation(tag, element_position);
        case tags.SequenceDelimitationItem.mask:
          return this._handle_sequencedelimitation(tag, element_position);
        default:
          return this._handle_element(tag, element_position);
      }
    };

    Decoder.prototype._decode_dataelement = function() {
      var element_position, tag, tag_str;
      this.saved = this.buffer.copy();
      if (log.trace()) {
        log.trace({
          buffer: this.saved.log_summary()
        }, "_decode_dataelement: saved buffer state");
      }
      element_position = this.buffer.stream_position;
      this.context.handle_autopops(element_position);
      tag = (new vrs.AT(this.context.top())).consume_value(this.buffer);
      if (log.debug()) {
        log.debug({
          tag: printf("%08x", tag)
        }, "decoded tag");
      }
      tag_str = printf("%08X", tag);
      switch (tag_str) {
        case tags.Item.mask:
          return this._handle_item(tag, element_position);
        case tags.ItemDelimitationItem.mask:
          return this._handle_itemdelimitation(tag, element_position);
        case tags.SequenceDelimitationItem.mask:
          return this._handle_sequencedelimitation(tag, element_position);
        default:
          return this._handle_element(tag, element_position);
      }
    };

    Decoder.prototype._action_wrapper = function(func) {
      var err;
      try {
        return func();
      } catch (_error) {
        err = _error;
        if (err != null ? err.doNotRestore : void 0) {
          return log.debug("_action_wrapper: streaming NeedMoreInput - no need to restore");
        } else if (err != null ? err.needMoreInput : void 0) {
          log.debug({
            buffer: this.buffer.log_summary()
          }, "_action_wrapper: need to restore");
          this.buffer = this.saved;
          return log.debug({
            needMoreInput: err.needMoreInput,
            buffer: this.buffer.log_summary(),
            error: err
          }, "_action_wrapper: restored buffer after NeedMoreInput");
        } else {
          log.error({
            error: err
          }, "_action_wrapper:  emitting error");
          return this.emit('error', err);
        }
      }
    };

    Decoder.prototype._guess_header = function() {
      var header, ts;
      this.saved = this.buffer.copy();
      header = this.buffer.easy_consume(132);
      if (header.length === 132 && header.toString("binary", 128, 132) === 'DICM') {
        log.debug("_guess_header: dicom header present, reading dicom datafile");
        this.buffer = this.saved;
        return this._decode_datafile();
      }
      if (header.length >= 6 && header.slice(0, 6).equals(new Buffer([0x08, 0x00, 0x05, 0x00, 0x43, 0x53]))) {
        log.debug("_guess_header: start with specific character set, ExplicitVRLittleEndian");
        this.buffer = this.saved;
        return this._decode_dataset();
      }
      if (header.length >= 4 && header.slice(0, 4).equals(new Buffer([0x08, 0x00, 0x05, 0x00]))) {
        log.debug("_guess_header: start with specific character set, ImplicitVRLittleEndian");
        ts = uids.for_uid('ImplicitVRLittleEndian');
        this.context.replace_root(ts.make_context());
        this.buffer = this.saved;
        return this._decode_dataset();
      }
      throw new vrs.DicomError("Unable to guess DICOM encoding");
    };

    Decoder.prototype._decode_datafile = function() {
      var header;
      this._switch_state(this._decode_datafile, "decoding preamble/header");
      this.saved = this.buffer.copy();
      header = this.buffer.consume(132);
      if (header.toString("binary", 128, 132) !== 'DICM') {
        throw new vrs.DicomError("No DICOM header found");
      }
      this._switch_state(this._decode_metainfo, "header decoded, decoding metainfo now");
      return this._decode_metainfo();
    };

    Decoder.prototype._consume_std_value_length = function() {
      var length_element;
      length_element = new vrs.UL(this.context.top_little_endian());
      return length_element.consume_value(this.buffer);
    };

    Decoder.prototype._handle_element = function(tag, start_position) {
      var is_explicit, tagdef, vr, vrstr;
      is_explicit = this.context.top().explicit;
      tagdef = tags.for_tag(tag);
      if (!is_explicit) {
        vrstr = tagdef.vr;
      } else {
        vrstr = this.buffer.consume(2).toString('binary');
      }
      if (log.debug()) {
        log.debug({
          vr: vrstr
        }, "_handle_element");
      }
      vr = vrs.for_name(vrstr, this.context.top());
      return vr.consume_and_emit(tagdef, this.buffer, this, start_position);
    };

    Decoder.prototype._handle_item = function(tag, start_pos) {
      var bd_length, bd_offset, element, end_cb, end_position, obj, value_length, _obj;
      value_length = this._consume_std_value_length();
      element = tags.for_tag(tag);
      if (this.context.top().encapsulated) {
        bd_offset = this.buffer.stream_position;
        bd_length = value_length;
        obj = new vrs.DicomEvent(element, null, start_pos, "start_item", null, bd_offset, bd_length);
        this.log_and_push(obj);
        _obj = new vrs.DicomEvent(element, null, start_pos, "end_item", null, bd_offset, bd_length);
        this._stream_bytes(value_length, _obj);
        return void 0;
      } else {
        end_position = void 0;
        if (value_length !== vrs.UNDEFINED_LENGTH) {
          end_position = this.buffer.stream_position + value_length;
        }
        end_cb = (function(_this) {
          return function() {
            _obj = new vrs.DicomEvent(element, null, start_pos, "end_item");
            return _this.log_and_push(_obj);
          };
        })(this);
        this.context.push({}, end_position, end_cb);
        obj = new vrs.DicomEvent(element, null, start_pos, "start_item");
        return this.log_and_push(obj);
      }
    };

    Decoder.prototype._handle_itemdelimitation = function(tag, start_position) {
      var obj, value_length;
      value_length = this._consume_std_value_length();
      obj = new vrs.DicomEvent(tags.for_tag(tag), null, start_position, 'end_item');
      this.context.pop();
      return this.log_and_push(obj);
    };

    Decoder.prototype._handle_sequencedelimitation = function(tag, start_position) {
      var command, obj, popped, value_length;
      value_length = this._consume_std_value_length();
      command = 'end_sequence';
      popped = this.context.pop();
      if ((popped != null ? popped.encapsulated : void 0) && !this.context.top().encapsulated) {
        command = 'end_element';
      }
      obj = new vrs.DicomEvent(tags.for_tag(tag), null, start_position, command);
      return this.log_and_push(obj);
    };

    Decoder.prototype._stream_bytes = function(bytes, emitObj, nextState) {
      var streamer;
      log.debug("_stream_bytes: arranging to stream " + bytes);
      streamer = new ByteStreamer({
        bytes: bytes,
        emitObj: emitObj,
        nextState: nextState,
        buffer: this.buffer,
        decoder: this
      });
      this._switch_state(streamer.stream_bytes, "byte_streamer_state");
      return streamer.stream_bytes();
    };

    Decoder.prototype.log_and_push = function(obj) {
      if (log.debug()) {
        log.debug({
          event: typeof obj.log_summary === "function" ? obj.log_summary() : void 0
        }, "Decoder: emitting dicom event");
      }
      return this.push(obj);
    };

    return Decoder;

  })(stream.Transform);

  ByteStreamer = (function() {
    function ByteStreamer(options) {
      this.stream_bytes = __bind(this.stream_bytes, this);
      this.bytes = options.bytes, this.emitObj = options.emitObj, this.nextState = options.nextState, this.buffer = options.buffer, this.decoder = options.decoder;
    }

    ByteStreamer.prototype.stream_bytes = function() {
      var buff, obj;
      while (this.bytes > 0) {
        buff = this.buffer.easy_consume(this.bytes);
        this.bytes -= buff.length;
        obj = new vrs.DicomEvent(void 0, void 0, void 0, void 0, buff);
        this.decoder.log_and_push(obj);
      }
      if (this.emitObj != null) {
        this.decoder.log_and_push(this.emitObj);
      }
      if (this.nextState == null) {
        this.nextState = this.decoder.decode_dataset;
      }
      return this.decoder._switch_state(this.nextState, "stream_bytes nextState");
    };

    return ByteStreamer;

  })();

  module.exports = Decoder;

  if (require.main === module) {
    fs.createReadStream(process.argv[2]).pipe(new Decoder({
      guess_header: true
    }));
  }

}).call(this);
