// Generated by CoffeeScript 1.8.0
(function() {
  var AE, AS, AT, BIG_ENDIAN, BigEndian, CS, CSObj, Context, ContextStack, DA, DS, DT, DicomError, DicomEvent, FD, FL, FixedLength, IS, LITTLE_ENDIAN, LO, LT, LittleEndian, NumberString, OB, OD, OF, OW, OtherVR, PN, SH, SL, SQ, SS, ST, Stringish, TM, UI, UL, UN, UNDEFINED_LENGTH, US, UT, UnexpectedEofOfFile, VR, for_name, iconv, log, _VR_DICT, _ends_with, _iconv_charset, _init_vr_names,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  log = require("./logger")("vrs");

  iconv = require("iconv-lite");

  UNDEFINED_LENGTH = 0xFFFFFFFF;

  DicomError = (function(_super) {
    __extends(DicomError, _super);

    function DicomError() {
      return DicomError.__super__.constructor.apply(this, arguments);
    }

    return DicomError;

  })(Error);

  UnexpectedEofOfFile = (function(_super) {
    __extends(UnexpectedEofOfFile, _super);

    function UnexpectedEofOfFile() {
      return UnexpectedEofOfFile.__super__.constructor.apply(this, arguments);
    }

    return UnexpectedEofOfFile;

  })(DicomError);

  exports.UNDEFINED_LENGTH = UNDEFINED_LENGTH;

  exports.DicomError = DicomError;

  exports.UnexpectedEofOfFile = UnexpectedEofOfFile;

  LittleEndian = (function() {
    function LittleEndian() {
      this.endianess = "LittleEndian";
    }

    LittleEndian.prototype.unpack_uint16 = function(buff) {
      return buff.readUInt16LE(0);
    };

    LittleEndian.prototype.unpack_uint16s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 2 * i;
        _results.push(buff.readUInt16LE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.unpack_int16s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 2 * i;
        _results.push(buff.readInt16LE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.unpack_uint32 = function(buff) {
      return buff.readUInt32LE(0);
    };

    LittleEndian.prototype.unpack_uint32s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readUInt32LE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.unpack_int32s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readInt32LE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.unpack_floats = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readFloatLE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.unpack_doubles = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 8 * i;
        _results.push(buff.readDoubleLE(offset));
      }
      return _results;
    };

    LittleEndian.prototype.pack_uint16s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 2);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 2 * idx;
        buff.writeUInt16LE(values[idx], offset);
      }
      return buff;
    };

    LittleEndian.prototype.pack_uint32s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeUInt32LE(values[idx], offset);
      }
      return buff;
    };

    LittleEndian.prototype.pack_int16s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 2);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 2 * idx;
        buff.writeInt16LE(values[idx], offset);
      }
      return buff;
    };

    LittleEndian.prototype.pack_int32s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeInt32LE(values[idx], offset);
      }
      return buff;
    };

    LittleEndian.prototype.pack_floats = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeFloatLE(values[idx], offset);
      }
      return buff;
    };

    LittleEndian.prototype.pack_doubles = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 8);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 8 * idx;
        buff.writeDoubleLE(values[idx], offset);
      }
      return buff;
    };

    return LittleEndian;

  })();

  BigEndian = (function() {
    function BigEndian() {
      this.endianess = "BigEndian";
    }

    BigEndian.prototype.unpack_uint16 = function(buff) {
      return buff.readUInt16BE(0);
    };

    BigEndian.prototype.unpack_uint16s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 2 * i;
        _results.push(buff.readUInt16BE(offset));
      }
      return _results;
    };

    BigEndian.prototype.unpack_int16s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 2 * i;
        _results.push(buff.readInt16BE(offset));
      }
      return _results;
    };

    BigEndian.prototype.unpack_uint32 = function(buff) {
      return buff.readUInt32BE(0);
    };

    BigEndian.prototype.unpack_uint32s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readUInt32BE(offset));
      }
      return _results;
    };

    BigEndian.prototype.unpack_int32s = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readInt32BE(offset));
      }
      return _results;
    };

    BigEndian.prototype.unpack_floats = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 4 * i;
        _results.push(buff.readFloatBE(offset));
      }
      return _results;
    };

    BigEndian.prototype.unpack_doubles = function(buff, num) {
      var i, offset, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        offset = 8 * i;
        _results.push(buff.readDoubleBE(offset));
      }
      return _results;
    };

    BigEndian.prototype.pack_uint16s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 2);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 2 * idx;
        buff.writeUInt16BE(values[idx], offset);
      }
      return buff;
    };

    BigEndian.prototype.pack_uint32s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeUInt32BE(values[idx], offset);
      }
      return buff;
    };

    BigEndian.prototype.pack_int16s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 2);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 2 * idx;
        buff.writeInt16BE(values[idx], offset);
      }
      return buff;
    };

    BigEndian.prototype.pack_int32s = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeInt32BE(values[idx], offset);
      }
      return buff;
    };

    BigEndian.prototype.pack_floats = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 4);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 4 * idx;
        buff.writeFloatBE(values[idx], offset);
      }
      return buff;
    };

    BigEndian.prototype.pack_doubles = function(values) {
      var buff, idx, offset, _i, _ref;
      buff = new Buffer(values.length * 8);
      for (idx = _i = 0, _ref = values.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        offset = 8 * idx;
        buff.writeDoubleBE(values[idx], offset);
      }
      return buff;
    };

    return BigEndian;

  })();

  LITTLE_ENDIAN = new LittleEndian();

  BIG_ENDIAN = new BigEndian();

  Context = (function() {
    function Context(ctx, obj) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this.endianess = (_ref = (_ref1 = obj.endianess) != null ? _ref1 : ctx != null ? ctx.endianess : void 0) != null ? _ref : LITTLE_ENDIAN;
      this.charset = (_ref2 = (_ref3 = obj.charset) != null ? _ref3 : ctx != null ? ctx.charset : void 0) != null ? _ref2 : "latin1";
      this.explicit = (_ref4 = (_ref5 = obj.explicit) != null ? _ref5 : ctx != null ? ctx.explicit : void 0) != null ? _ref4 : true;
      this.encapsulated = (_ref6 = (_ref7 = obj.encapsulated) != null ? _ref7 : ctx != null ? ctx.encapsulated : void 0) != null ? _ref6 : false;
    }

    return Context;

  })();

  CSObj = (function() {
    function CSObj(context, end_position, action) {
      this.context = context;
      this.end_position = end_position;
      this.action = action;
    }

    return CSObj;

  })();

  ContextStack = (function() {
    function ContextStack() {
      this._stack = [];
    }

    ContextStack.prototype.push = function(obj, end_position, action) {
      var context, csobj, rc, _ref;
      context = new Context((_ref = this.top()) != null ? _ref : {}, obj);
      csobj = new CSObj(context, end_position, action);
      if (log.trace()) {
        log.trace("pushing context: " + csobj);
      }
      rc = this._stack.push(csobj);
      if (log.trace()) {
        return log.trace({
          context: this.log_summary()
        }, "pushed context, this is current now!");
      }
    };

    ContextStack.prototype.replace_root = function(obj) {
      var context;
      context = new Context(this._stack[0].context, obj);
      this._stack[0].context = context;
      if (log.trace()) {
        return log.trace({
          context: this.log_summary()
        }, "replaced root context");
      }
    };

    ContextStack.prototype.replace_top = function(obj) {
      var context, csobj;
      csobj = this._stack[this._stack.length - 1];
      context = new Context(csobj.context, obj);
      csobj.context = context;
      if (log.trace()) {
        return log.trace({
          context: this.log_summary()
        }, "replaced top context");
      }
    };

    ContextStack.prototype.pop = function() {
      var csobj;
      csobj = this._stack.pop();
      if (log.trace()) {
        log.trace({
          context: this.log_summary()
        }, "popped context stack, this is current now!");
      }
      return csobj.context;
    };

    ContextStack.prototype.handle_autopops = function(pos) {
      var top;
      top = this._stack[this._stack.length - 1];
      if (top.end_position != null) {
        if (pos < top.end_position) {
          if (log.trace()) {
            log.trace("handle_autopops: pos " + pos + ", not reached end pos " + top.end_position);
          }
        } else {
          if (log.trace()) {
            log.trace("handle_autopops: pos " + pos + ", reached end pos " + top.end_position);
          }
          top.action();
          this._stack.pop();
          return this.handle_autopops(pos);
        }
      } else {
        if (log.trace()) {
          log.trace("handle_autopops: stream position " + pos + ", but no context with autopop on top");
        }
      }
      return this;
    };

    ContextStack.prototype.top = function() {
      var _ref;
      return (_ref = this._stack[this._stack.length - 1]) != null ? _ref.context : void 0;
    };

    ContextStack.prototype.top_little_endian = function() {
      var _top;
      _top = this.top();
      return new Context(_top, {
        endianess: LITTLE_ENDIAN
      });
    };

    ContextStack.prototype.stack_depth = function() {
      return this._stack.length;
    };

    ContextStack.prototype.log_summary = function() {
      var context, summary;
      context = this.top();
      return summary = {
        endianess: context.endianess,
        charset: context.charset,
        explicit: context.explicit,
        encapsulated: context.encapsulated,
        stack_depth: this._stack.length
      };
    };

    return ContextStack;

  })();

  _iconv_charset = function(spec_cs) {
    var _match;
    switch (spec_cs) {
      case 'GB18030':
        return 'gb18030';
      case 'ISO_IR 192':
        return 'utf8';
      default:
        if (!spec_cs) {
          return "latin1";
        }
        _match = spec_cs.match(/^ISO_IR (\d+)/);
        if (_match) {
          return 'isoir' + _match[1];
        }
        return spec_cs;
    }
  };

  DicomEvent = (function() {
    function DicomEvent(element, vr, offset, command, raw, bulkdata_offset, bulkdata_length) {
      this.element = element;
      this.vr = vr;
      this.offset = offset;
      this.command = command;
      this.raw = raw;
      this.bulkdata_offset = bulkdata_offset;
      this.bulkdata_length = bulkdata_length;
    }

    DicomEvent.prototype.log_summary = function() {
      var summary, _ref, _ref1, _ref2;
      summary = {
        element: (_ref = this.element) != null ? typeof _ref.log_summary === "function" ? _ref.log_summary() : void 0 : void 0,
        vr: (_ref1 = this.vr) != null ? typeof _ref1.log_summary === "function" ? _ref1.log_summary() : void 0 : void 0,
        offset: this.offset,
        command: this.command,
        raw: (_ref2 = this.raw) != null ? _ref2.length : void 0,
        bulkdata_offset: this.bulkdata_offset,
        bulkdata_length: this.bulkdata_length
      };
      return summary;
    };

    return DicomEvent;

  })();

  exports.DicomEvent = DicomEvent;

  VR = (function() {
    VR.prototype.is_endian = false;

    VR.prototype.explicit_value_length_bytes = 2;

    VR.prototype.implicit_value_length_bytes = 4;

    VR.prototype.base64_values = false;

    function VR(context, buffer, values) {
      this.context = context;
      if ((values != null) && (buffer == null)) {
        this.encode(values);
      } else {
        this.buffer = buffer;
      }
    }

    VR.prototype.value = function() {
      return this.values()[0];
    };

    VR.prototype._value_length_bytes = function() {
      var vlb;
      vlb = this.context.explicit ? this.explicit_value_length_bytes : this.implicit_value_length_bytes;
      if (log.trace()) {
        log.trace({
          length: vlb
        }, "value_length_bytes");
      }
      return vlb;
    };

    VR.prototype.consume_value_length = function(readbuffer) {
      var length_element, value_length, vlb;
      vlb = this._value_length_bytes();
      switch (vlb) {
        case 2:
          length_element = new US(this.context);
          break;
        case 4:
          length_element = new UL(this.context);
          break;
        case 6:
          readbuffer.consume(2);
          length_element = new UL(this.context);
          break;
        default:
          raise(new DicomError("incorrect value length bytes (not 2,4 or 6): " + vlb));
      }
      value_length = length_element.consume_value(readbuffer);
      return value_length;
    };

    VR.prototype._encode_value_length = function(encoder, value_length) {
      var length_element, vlb;
      if (value_length == null) {
        value_length = this.buffer.length;
      }
      vlb = this._value_length_bytes();
      switch (vlb) {
        case 2:
          length_element = new US(this.context, null, [value_length]);
          break;
        case 4:
          length_element = new UL(this.context, null, [value_length]);
          break;
        case 6:
          log.trace("encode_value_length: 6 byte VR, emitting 0x0000");
          encoder.push(new Buffer([0, 0]));
          length_element = new UL(this.context, null, [value_length]);
          break;
        default:
          raise(new DicomError("incorrect value length bytes (not 2,4 or 6): " + vlb));
      }
      if (log.trace()) {
        log.trace({
          length: length_element.buffer.length,
          value_length: value_length
        }, "encode_value_length: emitting value length");
      }
      return encoder.push(length_element.buffer);
    };

    VR.prototype.consume = function(readbuffer) {
      var value_length;
      value_length = this.consume_value_length(readbuffer);
      return this.buffer = readbuffer.consume(value_length);
    };

    VR.prototype.consume_and_emit = function(element, readbuffer, decoder, start_position) {
      var value_length;
      value_length = this.consume_value_length(readbuffer);
      return this._consume_and_emit_known_value_length(element, readbuffer, decoder, start_position, value_length);
    };

    VR.prototype._consume_and_emit_known_value_length = function(element, readbuffer, decoder, start_position, value_length) {
      var obj, _ref;
      if (value_length === UNDEFINED_LENGTH) {
        throw new DicomError("VR::consume_and_emit is not prepared to handle UNDEFINED_LENGTH");
      }
      if (value_length < ((_ref = decoder.streaming_value_length_minimum) != null ? _ref : 256)) {
        this.buffer = readbuffer.consume(value_length);
        obj = new DicomEvent(element, this, start_position, "element");
        return decoder.log_and_push(obj);
      } else {
        return this.stream_element(element, readbuffer, decoder, start_position, value_length);
      }
    };

    VR.prototype.stream_element = function(element, readbuffer, decoder, start_position, value_length) {
      var bd_length, bd_offset, obj;
      bd_offset = decoder.buffer.stream_position;
      bd_length = value_length;
      obj = new DicomEvent(element, this, start_position, "start_element", null, bd_offset, bd_length);
      decoder.log_and_push(obj);
      obj = new DicomEvent(element, this, start_position, "end_element", null, bd_offset, bd_length);
      return decoder._stream_bytes(value_length, obj);
    };

    VR.prototype._encode_and_emit = function(element, encoder) {
      this._encode_and_emit_tag_vr(element, encoder);
      this._encode_value_length(encoder);
      log.trace({
        length: this.buffer.length
      }, "_encode_and_emit: emitting vr buffer");
      return encoder.push(this.buffer);
    };

    VR.prototype._encode_and_emit_tag_vr = function(element, encoder) {
      var tag;
      if (log.trace()) {
        log.trace({
          tag: element.tag
        }, "_encode_and_emit_tag_vr: emitting tag");
      }
      tag = new AT(this.context, null, [element.tag]);
      encoder.push(tag.buffer);
      if (this.context.explicit) {
        if (log.trace()) {
          log.trace({
            vr: this.name
          }, "_encode_and_emit_tag_vr: emitting vr");
        }
        return encoder.push(new Buffer(this.name, "binary"));
      }
    };

    VR.prototype.log_summary = function() {
      var summary, _ref, _ref1;
      return summary = ((_ref = this.buffer) != null ? _ref.length : void 0) < 64 ? {
        values: this.values()
      } : {
        length: (_ref1 = this.buffer) != null ? _ref1.length : void 0
      };
    };

    return VR;

  })();

  FixedLength = (function(_super) {
    __extends(FixedLength, _super);

    function FixedLength() {
      return FixedLength.__super__.constructor.apply(this, arguments);
    }

    FixedLength.prototype.is_endian = true;

    FixedLength.prototype.single_value_length = 4;

    FixedLength.prototype.consume_value = function(rb) {
      this.buffer = rb.consume(this.single_value_length);
      return this.value();
    };

    FixedLength.prototype._vm = function(buffer) {
      return buffer.length / this.single_value_length;
    };

    return FixedLength;

  })(VR);

  AT = (function(_super) {
    __extends(AT, _super);

    function AT() {
      return AT.__super__.constructor.apply(this, arguments);
    }

    AT.prototype.values = function() {
      var g_e, idx, _i, _ref, _results;
      g_e = this.context.endianess.unpack_uint16s(this.buffer, this._vm(this.buffer) * 2);
      _results = [];
      for (idx = _i = 0, _ref = g_e.length; _i < _ref; idx = _i += 2) {
        _results.push((g_e[idx] << 16) ^ g_e[idx + 1]);
      }
      return _results;
    };

    AT.prototype.encode = function(values) {
      var e, g, g_e, v, _i, _len;
      g_e = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        v = values[_i];
        g = (v >> 16) & 0xFFFF;
        e = v & 0xFFFF;
        g_e.push(g);
        g_e.push(e);
      }
      return this.buffer = this.context.endianess.pack_uint16s(g_e);
    };

    return AT;

  })(FixedLength);

  FD = (function(_super) {
    __extends(FD, _super);

    function FD() {
      return FD.__super__.constructor.apply(this, arguments);
    }

    FD.prototype.single_value_length = 8;

    FD.prototype.values = function() {
      return this.context.endianess.unpack_doubles(this.buffer, this._vm(this.buffer));
    };

    FD.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_doubles(values);
    };

    return FD;

  })(FixedLength);

  FL = (function(_super) {
    __extends(FL, _super);

    function FL() {
      return FL.__super__.constructor.apply(this, arguments);
    }

    FL.prototype.values = function() {
      return this.context.endianess.unpack_floats(this.buffer, this._vm(this.buffer));
    };

    FL.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_floats(values);
    };

    return FL;

  })(FixedLength);

  SL = (function(_super) {
    __extends(SL, _super);

    function SL() {
      return SL.__super__.constructor.apply(this, arguments);
    }

    SL.prototype.values = function() {
      return this.context.endianess.unpack_int32s(this.buffer, this._vm(this.buffer));
    };

    SL.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_int32s(values);
    };

    return SL;

  })(FixedLength);

  SS = (function(_super) {
    __extends(SS, _super);

    function SS() {
      return SS.__super__.constructor.apply(this, arguments);
    }

    SS.prototype.single_value_length = 2;

    SS.prototype.values = function() {
      return this.context.endianess.unpack_int16s(this.buffer, this._vm(this.buffer));
    };

    SS.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_int16s(values);
    };

    return SS;

  })(FixedLength);

  UL = (function(_super) {
    __extends(UL, _super);

    function UL() {
      return UL.__super__.constructor.apply(this, arguments);
    }

    UL.prototype.values = function() {
      return this.context.endianess.unpack_uint32s(this.buffer, this._vm(this.buffer));
    };

    UL.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_uint32s(values);
    };

    return UL;

  })(FixedLength);

  US = (function(_super) {
    __extends(US, _super);

    function US() {
      return US.__super__.constructor.apply(this, arguments);
    }

    US.prototype.single_value_length = 2;

    US.prototype.values = function() {
      return this.context.endianess.unpack_uint16s(this.buffer, this._vm(this.buffer));
    };

    US.prototype.encode = function(values) {
      return this.buffer = this.context.endianess.pack_uint16s(values);
    };

    return US;

  })(FixedLength);

  OtherVR = (function(_super) {
    __extends(OtherVR, _super);

    function OtherVR() {
      return OtherVR.__super__.constructor.apply(this, arguments);
    }

    OtherVR.prototype.base64_values = true;

    OtherVR.prototype.explicit_value_length_bytes = 6;

    OtherVR.prototype.values = function() {
      return [this.buffer.toString('base64')];
    };

    return OtherVR;

  })(FixedLength);

  OB = (function(_super) {
    __extends(OB, _super);

    function OB() {
      return OB.__super__.constructor.apply(this, arguments);
    }

    OB.prototype.consume_and_emit = function(element, readbuffer, decoder, start_position) {
      var context, obj, value_length;
      value_length = this.consume_value_length(readbuffer);
      if (value_length !== UNDEFINED_LENGTH) {
        return this._consume_and_emit_known_value_length(element, readbuffer, decoder, start_position, value_length);
      }
      context = decoder.context;
      context.push({
        encapsulated: true
      });
      obj = new DicomEvent(element, this, start_position, "start_element");
      return decoder.log_and_push(obj);
    };

    return OB;

  })(OtherVR);

  UN = (function(_super) {
    __extends(UN, _super);

    function UN() {
      return UN.__super__.constructor.apply(this, arguments);
    }

    UN.prototype.consume_and_emit = function(element, readbuffer, decoder, start_position) {
      var end_cb, obj, value_length;
      value_length = this.consume_value_length(readbuffer);
      if (log.debug()) {
        log.debug({
          length: value_length
        }, "UN consume and emit");
      }
      if (value_length !== UNDEFINED_LENGTH) {
        return this._consume_and_emit_known_value_length(element, readbuffer, decoder, start_position, value_length);
      }
      end_cb = function() {
        var _obj;
        _obj = new DicomEvent(element, this, start_position, "end_sequence");
        return decoder.log_and_push(_obj);
      };
      decoder.context.push({
        explicit: false
      }, null, end_cb);
      obj = new DicomEvent(element, this, start_position, "start_sequence");
      return decoder.log_and_push(obj);
    };

    UN.prototype._encode_and_emit_seq = function(element, encoder) {
      this._encode_and_emit_tag_vr(element, encoder);
      this._encode_value_length(encoder, UNDEFINED_LENGTH);
      return encoder.context.push({});
    };

    return UN;

  })(OtherVR);

  OW = (function(_super) {
    __extends(OW, _super);

    function OW() {
      return OW.__super__.constructor.apply(this, arguments);
    }

    return OW;

  })(OtherVR);

  OF = (function(_super) {
    __extends(OF, _super);

    function OF() {
      return OF.__super__.constructor.apply(this, arguments);
    }

    return OF;

  })(OtherVR);

  OD = (function(_super) {
    __extends(OD, _super);

    function OD() {
      return OD.__super__.constructor.apply(this, arguments);
    }

    return OD;

  })(OtherVR);

  SQ = (function(_super) {
    __extends(SQ, _super);

    function SQ() {
      return SQ.__super__.constructor.apply(this, arguments);
    }

    SQ.prototype.explicit_value_length_bytes = 6;

    SQ.prototype.values = function() {
      return void 0;
    };

    SQ.prototype.consume_and_emit = function(element, readbuffer, decoder, start_position) {
      var end_cb, end_position, obj, value_length;
      value_length = this.consume_value_length(readbuffer);
      if (log.debug()) {
        log.debug({
          length: value_length
        }, "SQ consume and emit");
      }
      end_position = void 0;
      if (value_length !== UNDEFINED_LENGTH) {
        end_position = readbuffer.stream_position + value_length;
      }
      end_cb = function() {
        var _obj;
        _obj = new DicomEvent(element, this, start_position, "end_sequence");
        return decoder.log_and_push(_obj);
      };
      decoder.context.push({}, end_position, end_cb);
      obj = new DicomEvent(element, this, start_position, "start_sequence");
      return decoder.log_and_push(obj);
    };

    SQ.prototype._encode_and_emit = function(element, encoder) {
      throw new DicomError("internal error: _encode_and_emit should not be called");
    };

    SQ.prototype._encode_and_emit_seq = function(element, encoder) {
      this._encode_and_emit_tag_vr(element, encoder);
      this._encode_value_length(encoder, UNDEFINED_LENGTH);
      return encoder.context.push({});
    };

    return SQ;

  })(VR);

  _ends_with = function(str, char) {
    var len;
    len = str.length;
    return len > 0 && str[len - 1] === char;
  };

  Stringish = (function(_super) {
    __extends(Stringish, _super);

    function Stringish() {
      return Stringish.__super__.constructor.apply(this, arguments);
    }

    Stringish.prototype.allow_multiple_values = true;

    Stringish.prototype.padding_character = ' ';

    Stringish.prototype.split_str = '\\';

    Stringish.prototype.values = function() {
      var s;
      if (this.buffer == null) {
        return void 0;
      }
      s = iconv.decode(this.buffer, this.context.charset);
      if (s.length === 0) {
        return [];
      }
      if (_ends_with(s, this.padding_character)) {
        s = s.slice(0, -1);
      }
      if (this.allow_multiple_values) {
        return s.split(this.split_str);
      }
      return [s];
    };

    Stringish.prototype.encode = function(values) {
      var b, s;
      s = values.join(this.split_str) + this.padding_character;
      b = iconv.encode(s, this.context.charset);
      if (b.length % 2) {
        b = b.slice(0, -1);
      }
      return this.buffer = b;
    };

    return Stringish;

  })(VR);

  NumberString = (function(_super) {
    __extends(NumberString, _super);

    function NumberString() {
      return NumberString.__super__.constructor.apply(this, arguments);
    }

    NumberString.prototype.values = function() {
      return NumberString.__super__.values.call(this).map(Number);
    };

    return NumberString;

  })(Stringish);

  AE = (function(_super) {
    __extends(AE, _super);

    function AE() {
      return AE.__super__.constructor.apply(this, arguments);
    }

    return AE;

  })(Stringish);

  AS = (function(_super) {
    __extends(AS, _super);

    function AS() {
      return AS.__super__.constructor.apply(this, arguments);
    }

    return AS;

  })(Stringish);

  CS = (function(_super) {
    __extends(CS, _super);

    function CS() {
      return CS.__super__.constructor.apply(this, arguments);
    }

    CS.prototype._consume_and_emit_known_value_length = function(element, readbuffer, decoder, start_position, value_length) {
      var iconv_cs, spec_cs;
      CS.__super__._consume_and_emit_known_value_length.call(this, element, readbuffer, decoder, start_position, value_length);
      if (element.tag === 0x00080005) {
        spec_cs = this.value();
        log.debug({
          charset: spec_cs
        }, "CS: detected 0008,0005 SpecificCharacterSet");
        iconv_cs = _iconv_charset(spec_cs);
        return decoder.context.replace_top({
          charset: iconv_cs
        });
      }
    };

    return CS;

  })(Stringish);

  DA = (function(_super) {
    __extends(DA, _super);

    function DA() {
      return DA.__super__.constructor.apply(this, arguments);
    }

    return DA;

  })(Stringish);

  DS = (function(_super) {
    __extends(DS, _super);

    function DS() {
      return DS.__super__.constructor.apply(this, arguments);
    }

    return DS;

  })(NumberString);

  DT = (function(_super) {
    __extends(DT, _super);

    function DT() {
      return DT.__super__.constructor.apply(this, arguments);
    }

    return DT;

  })(Stringish);

  IS = (function(_super) {
    __extends(IS, _super);

    function IS() {
      return IS.__super__.constructor.apply(this, arguments);
    }

    return IS;

  })(NumberString);

  LO = (function(_super) {
    __extends(LO, _super);

    function LO() {
      return LO.__super__.constructor.apply(this, arguments);
    }

    return LO;

  })(Stringish);

  LT = (function(_super) {
    __extends(LT, _super);

    function LT() {
      return LT.__super__.constructor.apply(this, arguments);
    }

    LT.prototype.allow_multiple_values = false;

    return LT;

  })(Stringish);

  PN = (function(_super) {
    __extends(PN, _super);

    function PN() {
      return PN.__super__.constructor.apply(this, arguments);
    }

    PN.prototype.values = function() {
      var obj, v, _groups, _i, _len, _results, _values;
      _values = PN.__super__.values.call(this);
      _results = [];
      for (_i = 0, _len = _values.length; _i < _len; _i++) {
        v = _values[_i];
        _groups = v != null ? v.split("=") : void 0;
        obj = {};
        if (_groups[0] != null) {
          obj.Alphabetic = _groups[0];
        }
        if (_groups[1] != null) {
          obj.Ideographic = _groups[1];
        }
        if (_groups[2] != null) {
          obj.Phonetic = _groups[2];
        }
        _results.push(obj);
      }
      return _results;
    };

    PN.prototype.encode = function(values) {
      var groups, str_values, v;
      str_values = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          v = values[_i];
          if ((typeof v) === 'object') {
            groups = [];
            if (v.Alphabetic != null) {
              groups[0] = v.Alphabetic;
            }
            if (v.Ideographic != null) {
              groups[1] = v.Ideographic;
            }
            if (v.Phonetic != null) {
              groups[2] = v.Phonetic;
            }
            _results.push(groups.join("="));
          } else {
            _results.push(v);
          }
        }
        return _results;
      })();
      return PN.__super__.encode.call(this, str_values);
    };

    return PN;

  })(Stringish);

  SH = (function(_super) {
    __extends(SH, _super);

    function SH() {
      return SH.__super__.constructor.apply(this, arguments);
    }

    return SH;

  })(Stringish);

  ST = (function(_super) {
    __extends(ST, _super);

    function ST() {
      return ST.__super__.constructor.apply(this, arguments);
    }

    ST.prototype.allow_multiple_values = false;

    return ST;

  })(Stringish);

  TM = (function(_super) {
    __extends(TM, _super);

    function TM() {
      return TM.__super__.constructor.apply(this, arguments);
    }

    return TM;

  })(Stringish);

  UI = (function(_super) {
    __extends(UI, _super);

    function UI() {
      return UI.__super__.constructor.apply(this, arguments);
    }

    UI.prototype.padding_character = "\x00";

    return UI;

  })(Stringish);

  UT = (function(_super) {
    __extends(UT, _super);

    function UT() {
      return UT.__super__.constructor.apply(this, arguments);
    }

    UT.prototype.allow_multiple_values = false;

    UT.prototype.explicit_value_length_bytes = 6;

    return UT;

  })(Stringish);

  _VR_DICT = {
    'AT': AT,
    'FD': FD,
    'FL': FL,
    'SL': SL,
    'SS': SS,
    'UL': UL,
    'US': US,
    'OB': OB,
    'UN': UN,
    'OW': OW,
    'OF': OF,
    'OD': OD,
    'SQ': SQ,
    'AE': AE,
    'AS': AS,
    'CS': CS,
    'DA': DA,
    'DS': DS,
    'DT': DT,
    'IS': IS,
    'LO': LO,
    'LT': LT,
    'PN': PN,
    'SH': SH,
    'ST': ST,
    'TM': TM,
    'UI': UI,
    'UT': UT
  };

  _init_vr_names = function() {
    var name, vr;
    for (name in _VR_DICT) {
      vr = _VR_DICT[name];
      vr.prototype.name = name;
    }
    return void 0;
  };

  _init_vr_names();

  for_name = function(name, ctx, buffer, values) {
    var constr_fn;
    if (name === 'OB or OW') {
      if (log.debug()) {
        log.debug({
          vr: 'OW'
        }, "for_name: using OW for 'OB or OW'");
      }
      name = 'OW';
    }
    if (name === 'US or SS') {
      if (log.debug()) {
        log.debug({
          vr: 'SS'
        }, "for_name: using SS for 'US or SS'");
      }
      name = 'SS';
    }
    constr_fn = _VR_DICT[name];
    if (constr_fn == null) {
      throw new DicomError("Unknown VR: " + name);
    }
    return new constr_fn(ctx, buffer, values);
  };

  exports.LITTLE_ENDIAN = LITTLE_ENDIAN;

  exports.BIG_ENDIAN = BIG_ENDIAN;

  exports.Context = Context;

  exports.ContextStack = ContextStack;

  exports.AT = AT;

  exports.FD = FD;

  exports.FL = FL;

  exports.SL = SL;

  exports.SS = SS;

  exports.UL = UL;

  exports.US = US;

  exports.OB = OB;

  exports.OW = OW;

  exports.OF = OF;

  exports.OD = OD;

  exports.UN = UN;

  exports.SQ = SQ;

  exports.AE = AE;

  exports.AS = AS;

  exports.CS = CS;

  exports.DA = DA;

  exports.DS = DS;

  exports.DT = DT;

  exports.IS = IS;

  exports.LO = LO;

  exports.LT = LT;

  exports.PN = PN;

  exports.SH = SH;

  exports.ST = ST;

  exports.TM = TM;

  exports.UI = UI;

  exports.UT = UT;

  exports.for_name = for_name;

  exports._VR_DICT = _VR_DICT;

}).call(this);
