// Generated by CoffeeScript 1.8.0
(function() {
  var NeedMoreInput, ReadBuffer, log,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  log = require("./logger")("readbuffer");

  ReadBuffer = (function() {
    function ReadBuffer() {
      if (!(this instanceof ReadBuffer)) {
        return new ReadBuffer();
      }
      this.offset = 0;
      this.stream_position = 0;
      this.buffers = [];
      this.length = 0;
    }

    ReadBuffer.prototype.log_summary = function() {
      var summary;
      summary = {
        offset: this.offset,
        stream_position: this.stream_position,
        length: this.length,
        num_buffers: this.buffers.length
      };
      return summary;
    };

    ReadBuffer.prototype.copy = function() {
      var rb, _;
      rb = new ReadBuffer();
      rb.offset = this.offset;
      rb.stream_position = this.stream_position;
      rb.buffers = (function() {
        var _i, _len, _ref, _results;
        _ref = this.buffers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ = _ref[_i];
          _results.push(_);
        }
        return _results;
      }).call(this);
      rb.length = this.length;
      return rb;
    };

    ReadBuffer.prototype.push = function(buffer) {
      var rc;
      rc = this.buffers.push(buffer);
      this.length += buffer.length;
      return rc;
    };

    ReadBuffer.prototype.has = function(num_bytes) {
      return num_bytes <= this.length;
    };

    ReadBuffer.prototype.consume = function(bytes) {
      var buff, dst, dstPos, end, len, numBytes;
      if (!this.has(bytes)) {
        throw new NeedMoreInput(bytes);
      }
      if (bytes === 0) {
        return new Buffer(0);
      }
      end = this.offset + bytes;
      buff = this.buffers[0];
      if (end <= buff.length) {
        dst = buff.slice(this.offset, end);
        this.offset += bytes;
      } else {
        dst = new Buffer(bytes);
        buff.copy(dst, 0, this.offset, buff.length);
        dstPos = len = buff.length - this.offset;
        this.offset = 0;
        this.buffers.shift();
        numBytes = bytes - len;
        while (numBytes > 0) {
          buff = this.buffers[0];
          len = Math.min(numBytes, buff.length);
          buff.copy(dst, dstPos, 0, len);
          numBytes -= len;
          dstPos += len;
          if (len === buff.length) {
            this.buffers.shift();
            len = 0;
          }
        }
        this.offset = len;
      }
      this.length -= bytes;
      this.stream_position += bytes;
      if (this.offset === buff.length) {
        this.offset = 0;
        this.buffers.shift();
      }
      return dst;
    };

    ReadBuffer.prototype.easy_consume = function(bytes) {
      var buff, dst, end;
      if (this.length === 0) {
        throw new NeedMoreInput(0, true);
      }
      end = this.offset + bytes;
      buff = this.buffers[0];
      if (end > buff.length) {
        end = buff.length;
        bytes = buff.length - this.offset;
      }
      dst = buff.slice(this.offset, end);
      this.offset += bytes;
      this.length -= bytes;
      this.stream_position += bytes;
      if (this.offset === buff.length) {
        this.offset = 0;
        this.buffers.shift();
      }
      return dst;
    };

    ReadBuffer.prototype.indexOf = function(needle) {
      var buff, buff_length, buffers, buffers_length, dpos, i, j, offset, what, _i, _j, _k;
      if (this.length === 0) {
        return -1;
      }
      what = (new Buffer(needle))[0];
      buffers = this.buffers;
      buffers_length = this.buffers.length;
      buff = buffers[0];
      buff_length = buff.length;
      offset = this.offset;
      for (i = _i = offset; offset <= buff_length ? _i < buff_length : _i > buff_length; i = offset <= buff_length ? ++_i : --_i) {
        if (buff[i] === what) {
          return i - offset;
        }
      }
      dpos = buff_length - offset;
      for (j = _j = 1; 1 <= buffers_length ? _j < buffers_length : _j > buffers_length; j = 1 <= buffers_length ? ++_j : --_j) {
        buff = buffers[j];
        buff_length = buff.length;
        for (i = _k = 0; 0 <= buff_length ? _k < buff_length : _k > buff_length; i = 0 <= buff_length ? ++_k : --_k) {
          if (buff[i] === what) {
            return dpos + i;
          }
        }
        dpos += buff_length;
      }
      return -1;
    };

    ReadBuffer.prototype.has_line = function() {
      var idx;
      idx = this.indexOf('\n');
      if (idx >= 0) {
        return idx + 1;
      } else {
        return 0;
      }
    };

    return ReadBuffer;

  })();

  NeedMoreInput = (function(_super) {
    __extends(NeedMoreInput, _super);

    function NeedMoreInput(needMoreInput, doNotRestore) {
      this.needMoreInput = needMoreInput;
      this.doNotRestore = doNotRestore;
      NeedMoreInput.__super__.constructor.call(this, "Need " + this.needMoreInput + " more input.");
    }

    return NeedMoreInput;

  })(Error);

  module.exports = ReadBuffer;

}).call(this);
